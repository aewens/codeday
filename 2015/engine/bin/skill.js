// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(["player", "pappai"], function(Player, Pappai) {
    var Skill;
    return Skill = (function(_super) {
      __extends(Skill, _super);

      function Skill(x, y, r, difficulty, color) {
        var opts;
        this.x = x;
        this.y = y;
        this.r = r;
        this.difficulty = difficulty;
        this.color = color;
        Skill.__super__.constructor.call(this, this.x, this.y, this.r, this.difficulty, this.color);
        opts = {
          fcolor: "hsla(60, 100%, 50%, 0.5)",
          scolor: "hsl(80, 100%, 50%)",
          doStroke: true
        };
        this.mpulsar = Pappai.Circle(this.r + 5).flag(opts);
        this.mpulsate = false;
        this.mpulsing = 0;
        this.cap = 10;
      }

      Skill.prototype.stats = function(konst, xup, M, prune, quell, power) {
        this.konst = konst;
        this.xup = xup;
        this.M = M;
        this.prune = prune;
        this.quell = quell;
        this.power = power;
        return this.E = {
          k: this.konst,
          x: this.xup,
          m: this.M,
          h: this.health,
          r: 1,
          p: this.prune,
          q: this.quell
        };
      };

      Skill.prototype.mana = function(potency, sum, distance, greed) {
        return this.M = this.M + (potency * sum) / (pow(distance, greed));
      };

      Skill.prototype.energy = function(energy) {
        this.E = {
          k: this.konst,
          x: this.xup,
          m: this.M,
          h: this.health,
          r: this.pulsar.radius,
          p: this.prune,
          q: this.quell
        };
        return energy.check(this.E.k, this.E.x, this.E.m, this.E.h, this.E.r, this.E.p, this.E.q);
      };

      Skill.prototype.pulse = function(energy) {
        this.pulsar.radius = this.real.radius + abs(sin(this.pulsing * 2)) * 500;
        if (floor(this.pulsing * 100) % 5 === 0) {
          this.E = {
            k: this.konst,
            x: this.xup,
            m: this.M,
            h: this.health,
            r: this.pulsar.radius,
            p: this.prune,
            q: this.quell
          };
          this.damage = energy.calc(this.E.k, this.E.x, this.E.m, this.E.h, this.E.r, this.E.p, this.E.q);
          this.M = this.M - this.damage;
          if (this.M < 1) {
            return this.M = 1;
          }
        }
      };

      Skill.prototype.mpulse = function(level) {
        var greed, sum;
        if (this.M > 300) {
          return;
        }
        this.mpulsar.radius = this.real.radius + abs(sin(this.mpulsing * 25)) * 50;
        if (floor(this.mpulsing * 10) % 5 === 0) {
          sum = pi * sqre(this.mpulsar.radius) / 1000;
          greed = 2;
          this.mana(this.power, sum, this.mpulsar.radius, greed);
          level.mana = level.mana - this.M;
          if (level.mana < this.cap) {
            return level.mana = this.cap;
          }
        }
      };

      Skill.prototype.update = function(map, energy, level) {
        Skill.__super__.update.call(this, map, energy);
        if (this.pulsate && energy.E > energy.low) {
          this.pulse(energy);
        }
        if (this.mpulsate) {
          return this.mpulse(level);
        }
      };

      Skill.prototype.render = function() {
        return Skill.__super__.render.apply(this, arguments);
      };

      return Skill;

    })(Player);
  });

}).call(this);
