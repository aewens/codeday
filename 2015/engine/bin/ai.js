// Generated by CoffeeScript 1.7.1
(function() {
  define(["pappai", "vector", "player"], function(Pappai, Vector, Player) {
    var AI;
    AI = (function() {
      function AI(x, y, r, color) {
        this.x = x;
        this.y = y;
        this.r = r;
        this.color = color;
        this.Reecelet = Pappai.Circle(this.r).fg(this.color).set(this.x, this.y);
        this.Ewensian = new Vector(this.x, this.y);
        this.type = true;
        this.real = this.Reecelet;
        this.logic = this.Ewensian;
        this.collided = false;
        this.into = null;
        this.G = 5;
        this.gravity = new Vector(0, this.G);
        this.velocity = new Vector(0, 0);
        this.friction = 0.9;
        this.canJump = false;
      }

      AI.prototype.move = function(x, y) {
        return this.velocity = this.velocity.add2(x, y);
      };

      AI.prototype.collide = function(map, player, others) {
        var collided, ctc, cts, h, logic, object, objr, objs, objx, objy, real, self, w, _i, _len, _ref;
        w = map.w * map.size;
        h = map.h * map.size;
        if (this.logic.x < this.r) {
          this.logic = new Vector(this.r, this.logic.y);
        }
        if (this.logic.x >= w - this.r) {
          this.logic = new Vector(w - this.r - 1, this.logic.y);
        }
        if (this.logic.y < this.r) {
          this.logic = new Vector(this.logic.x, this.r);
        }
        if (this.logic.y >= h - this.r) {
          this.logic = new Vector(this.logic.x, h - this.r - 1);
        }
        self = this;
        logic = this.logic;
        ctc = function(c, r) {
          return self.r + r > c.sub(self.logic).mag();
        };
        cts = function(x, y, s) {
          var c, cx, cy, d2;
          cx = clamp(self.logic.x, x, x + s);
          cy = clamp(self.logic.y, y, y + s);
          c = new Vector(cx, cy);
          d2 = ceil(self.logic.sub(c).mag());
          return d2 < self.r;
        };
        collided = false;
        _ref = [player].concat(others).concat(map.world);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          object = _ref[_i];
          if (collided) {
            continue;
          }
          logic = object.logic;
          real = object.real;
          objx = real.x;
          objy = real.y;
          if (real.side != null) {
            objs = real.side;
          }
          if (real.radius != null) {
            objr = real.radius;
          }
          collided = object.type ? ctc(logic, objr) : cts(objx, objy, objs);
          if (collided) {
            this.into = object;
          }
        }
        this.collided = collided;
        if (this.into instanceof Player) {
          if (player.health > 0) {
            player.health = player.health - 1;
          }
        }
        return this.collided;
      };

      AI.prototype.update = function(map, player, others) {
        var attract, dir, lr, ud;
        attract = player.logic.sub(this.logic);
        if (attract.mag() < 250) {
          lr = attract.x > 0 ? 1 : -1;
          ud = attract.y < 0 && this.canJump ? -5 : 0;
          ud = this.logic.y >= map.h * map.size - this.r * 2 ? -20 : ud;
          this.velocity = this.velocity.add2(lr, ud);
        } else {
          this.velocity = new Vector(0, 0);
        }
        this.velocity = this.velocity.scale(this.friction);
        this.logic = this.logic.add(this.gravity).add(this.velocity);
        if (this.collide(map, player, others)) {
          dir = this.into.logic.sub(this.logic).dot(this.gravity);
          if (dir >= 35) {
            this.logic = this.logic.sub(this.gravity);
            this.canJump = true;
          } else if (dir <= -35) {

          } else {
            this.logic = this.logic.sub(this.velocity).sub(this.gravity);
          }
        } else {
          this.canJump = false;
        }
        return this.real.set(this.logic.x, this.logic.y);
      };

      AI.prototype.render = function() {
        return this.real.render();
      };

      return AI;

    })();
    return AI;
  });

}).call(this);
